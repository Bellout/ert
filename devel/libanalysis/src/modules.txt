Overview
--------
The ERT application has evolved into a quite complex beast. Originally
the actual EnKF algorithm was located very deep down in the code, and
changes to the EnKF algorithm required detailed knowledge about the
enkf_node objects, the datatype for measurements and observations,
serialisation and so on. Quite complex and fragile stuff.

To facilitate easier development and testing of new update schemes the
core EnKF update step has been factored out as analysis modules, which
are called from the enkf_main scope. The update functions in the
module get ordinary matrices as input, and do not need to know
anything about the internals of the ERT application. 

The modules can either be built in, or you can compile your own module
as a shared library and load it runtime. Apart from the initial
loading internal modules and external modules are treated 100%
identically.


How modules work
----------------


Loading modules
---------------


Interacting with modules
------------------------
The modules can implement four different functions to set a scalar
value. The four functions have signature:

   bool set_int (void * module_data, const char * var_name , int value)
   bool set_double( void * module_data , const char * var_name , double value)
   bool set_bool( void * module_data , const char * var_name , bool value )
   bool set_string( void * module_data , const char * var_name , const char * value )

Common for all these functions is:

  1. It is not necessary to implement these functions; if you know
     that the module has no internal integer variables which should be
     user-modifiable you can just set the set_int function pointer to
     NULL.

  2. If the module recognizes the variable name and actually sets an
     internal variable it should return true, otherwise return false.

  3. The set_xxx() functions are called from the wrapper function
     analysis_module_set_var(); when calling the wrapper function the
     value variable is a string which we try to convert to int, double
     and bool respectively and then cascade through the functions in
     the order listed above. This involves two things:

       a) A module has an internal namespace which is shared among all
          variable types.

       b) If the string value argument is incorrectly formatted,
          i.e. an integer is passed as "12x" the correct low level
          function will not be called.

The method to get information out from the module is much more
limited. Each module should contain an internal variable:

    long option_flags;

And when instantiating the private module you should initialize the
option_flags variable by adding together the relevant options from
analysis_module.h. The enkf_main_UPDATE() method which invokes the
module functions will inspect the option_flags to see which variables
to pass to the module, and which module functions to invoke, so this
must be correct.


Example 
------- 
The module/file std_enkf.c is commented quite heavily to serve as an
example.




