1. Static and shared libraries 
------------------------------ 

The ert application is based on the internal libraries
libutil,libecl,librms,libsched,libconfig,libplot,libjob_queue and
libenkf. When creating a final ert executable this is done by linking
in static versions of all these libraries. The consistent use of
static libraries makes the system much more robust for updates, and
also easier to have several versions of ERT installed side-by-side.

The gcc linker will by default link with the shared version of a
library, so if both libXXX.a and libXXX.so are found the shared
version libXXX.so will be used. When linking ert the linker is tould
where to locate the internal libraries, but no further -dynamic /
-static options are given. Since only static versions of the internal
libraries can be found the resulting linking will be:

   * All the internal libraries are linked statically
   
   * All standard libraries like libz, libpthread and liblapack are
     linked dynamically.

This has worked quite OK for a long time, but the advent of Python
bindings, both for the Python wrapper and for the gui have increased
the complexity, the Python bindings require shared
libraries. Currently the shared libaries are just installed in a slib/
subdirectory beside the lib/ directory, i.e. for e.g. libecl we have:

   libecl/src/...
   libecl/include/...
   libecl/lib/libecl.a
   libecl/slib/libecl.so

The normal unix way is to have the shared and static libraries located
in the same place, but that will not work with the current ert link
procedure:

   * Just putting libXXX.so and libXXX.a in the same location without
     any updates to the link routine will result in the linker using
     the shared versions.

   * Passing the -static link option to gcc will result in a fully
     static ert, i.e. also the standard libraries will be linked in
     statically.

Both of these solutions are unsatisfactory. Currently the shared
libaries are installed globally as:

   /project/res/x86_64_RH_X/lib/python/lib/libXXX.so

and

   /d/proj/bg/enkf/ERT_GUI/lib/libXXX.so

for the Python bindings and the GUI respectively. These shared
libraries are of of course the same both the Python bindings and the
GUI, and should be assembled in the same point. Observe that GUI is
only installed in the Bergen location /d/proj/bg/enkf and should of
course be moved to /project/res.

It is not entirely clear to me how to achieve the goals:

  * The main ert application links with the static version of the
    internal libraries.

  * The shared and static version of the internal libraries can
    coexist in the same location.

One solution might be to pass the library to link with explicitly to
the linker, i.e. instead of the normal link command:

   gcc -o exe object1.o object2.o -L/path/to/lib1 -L/path/to/lib2 -l1 -l2

where you tell gcc where to search and which libraries to use, you can
alteranatively specify the link command fully like:

   gcc -o exe object1.o object2.o /path/to/lib1/lib1.a /path/to/lib2/lib2.a

But how to tell SCons this?
