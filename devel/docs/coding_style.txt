Object oriented

The code is written in plain C - but it is written in a somewhat
obejct oriented style. The programming paradigm which has been
followed quite closely is as follows: (1): There is one datatype (i.e.
on struct) defined in each file; the actual struct declaration is in
the source file (the header only has a typedef), this ensures that the
details of the datastructure can only be read/written from within the
source file, access from different files must be through accessor
functions. The probably best example of this is to look at the libecl
library. All objects should be initialized with specialized functions,
which ensures that the object is initialized to a consistent state. To
return from a (public) function with an object in an inconsistent
state is a cardinal sin.


Error handling

The code does not handle errors; it gives a reasonable message of what
is wrong, and immediately aborts. This is by design. However - every
attempt has been made to try and identify the error situations, i.e.
all switch statements have a default+++


Naming

I have tried quite hard to be consistent in the choice of names. In
particular the following conventions have been adhereded to: (1) all
functions with _alloc in the name allocate memory, which the calling
unit is responsible for freeing (see more on memory management). (2) I
have tried to reuse names from the standard library, i.e. a function
containing the _fread will use the fread() system call to read an
unformatted byte stream from disk.


Memory management

All functions which allocate new storage should contain "alloc" in the
name; if a function allocating memory does not have alloc in the name
it is a bug. A function with "alloc" in the name signals that the
calling scope is responsible for freeing up the memory. For functions
returning newly allocated memory of standard type, i.e. a char * or
double * pointer, the calling scope should just free the memory with
free(), otherwise a specialized _free function should be called.
There are several functions containing "_ref" in the name, they give
out a pointer to an internal data structure. In most cases these
pointers should be read-only (in which case they are const *).  Most
of the input-pointers when creating an object are internalized
(i.e. copied), so that the calling unit is free to do whatever it
wants pointers after it has been used to initialize an object. A
noteable exception here are the ***_config objects in the enkf
library.


MACROS

There is some use of macros - in particular to create type-safe
accessor functions, not so many of macros are exported. All macros
have CAPITAL NAMES.


The libraries

The current enkf code is organized in several libraries. The
librarires are designed to do / work with one thing each. Common
principle for the libraries are the following: They have a common
namespace; i.e. all the files and functions in the libecl library have
ecl_xxx prefix. The exception to this are the libutil and libenkf
libraries, where there are many files which don't use the util_ and
enkf_ prefixes.

The different libraries (with dependencies) are as follows:

libhash: This library implements a hash_type. The hash_type is quite
  heavily used in the the remaining part of the code.

libutil (libhash): This library implements some objects, in particular
  void_arg_type for packing arguments, and path_fmt_type for
  "automatic" creation of filenames/directories - but the the most
  important part of libutil is implemented in util.c, which is just a
  collection of useful functions. These include functions for reading
  and writing to files, manipulating strings, allocating memory and
  reading/writing compressed streams.

libecl(libhash , libutil): This library implements low-level functions
  for reading and writing eclipse restart and summary files (also
  RFT/INIT/GRID/EGRID). All these files are built up by structures
  which are called eclipse keywords (ecl_kw). A keyword has a name, a
  size, a datatype and the actual data. The ecl_kw_type is one of the
  most fundamental types.

libsched(libhash , libutil , libecl): This library is basically a
  parser for the SCHEDULE file. In addition it contains the history
  object.

librms(libecl , libhash , libutil): This library implements reading
  and writing of (binary) ROFF files - not fully complete, but seems
  to work OK.

libecl_que (libecl, libhash , libutil): Library to implement a que of
  ECLIPSE jobs, not currently in use. Look at libecl/src/lsf_jobs.c -
  which is quite crappy but works reasonably OK.

libsample + libanalysis: Fortran libraries.

libenkf (depends on everything): For this library there has been a
  consistent trend to split configuration and data in different
  objects.  I.e. the MULTZ estimator is implemented in multz.c, and
  all the multz estimators in an ensemble (i.e. typically 100) share
  opne multz_config instance. This is to ensure that configuration
  information is automatically shared among all ensemble members.
