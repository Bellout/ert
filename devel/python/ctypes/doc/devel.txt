Developer documentation
-----------------------

  1 Summary
  2 About ctypes
    2.1 Loading the shared library
    2.2 Type mappings
      2.2.1 Fundamental types
      2.2.2 User defined types and classes
  3 The C code
  4 Common structure of the wrapping
    4.1 Loading the shared library
    4.2 Prototyping
    4.3 The pure python code 
  5 Caveats 
    5.1 Garbage collection 
    5.2 Funny types
  6 Installation in Statoil



1 Summary

The ert Python classes are based on wrapping (some) of the C libraries
which constitute the ERT application. The wrapping is based on the
python ctypes module which does the wrapping dynamically. The python
classes are quite thin, most of the actual code is in C, however a
user of the ert Python should NOT need to know that there is some C
code deep down.


2 About ctypes

ctypes is a standard Python module for dynamic wrapping of C code. The
C code should compiled into a shared library. The ctypes library works
by loading the shared library with dlopen(). In addition there is a
quite good system for transparently mapping between Python types and C
types. More extensive documentation of ctypes is available at:
http://www.python.org/org/library/ctypes.html

2.1 Loading the shared library 

In the ert Python wrapping loading the shared library is handled by
the ert.util.clib function load(). When the shared library has been
loaded, all the symbols of the shared library are available ass
attributes of the ctypes load handle, as illustrated in the following
example base on libc:

    clib_handle = ctypes.CDLL( "libc" )
    print clib_handle.getenv

Now clib_handle.getenve will be a pointer to a Python function
object. Before this is really usable we have to "tell" the function
object input and out arguments, this is done with the restype
attribute and the argtypes attribute.. For the getenv() function which
takes (char *) input and also returns a (char *) pointer this would be:

    clib_handle.getenv.restype  =   ctypes.c_char_p
    clib_handle.getenv.argtypes = [ ctypes.c_char_p ] 
    
2.2 Type mappings 

The ctypes library automagically handles conversion between common
C-types and Python types, so for the example above we would be able to
write:

    PATH = clib_handle.getenv( "PATH" )

And the conversion between Python strings and NULL based char* in C is
handled transparently. In the ert wrapping setting the type of return
values and input values is handled by the function prototype() in
ert.cwrap.cwrap.

The type mappings necessary to get prototype() function to work is
maintained in the CWrapper class in ert.cwrap.cwrap.py. During
initialization of the ert Python code there are many calls
associating the name of a C type you whish to use in the prototype
process (as a string) and the corresponding Python type:
   
   CWrapper.registerType( "int"    , ctypes.c_int )
   CWrapper.registerType( "double" , ctypes.c_double ) 
   CWrapper.registerType( "char*"  , ctypes.c_char_p )                          
   CWrapper.registerType( "int*"   , ctypes.POINTER( ctypes.c_int ))
   

2.2.1 Fundamental types

All the fundamental C types are known to the ctypes library, and
transparently converted <-> the correct Python type. 

  C type                    ctypes             Python type 
  --------------------------------------------------------
  int                       c_int              int
  float                     c_float            float
  double                    c_double           double      
  .....
  char * (NULL terminated)  c_char_p           string
  --------------------------------------------------------   

All these types can be created by calling them with an optional
initializer of the correct type and value:

  cint = ctypes.c_int( 42 )

With the function ctypes.POINTER() you can create pointers to the
fundamental types - but this is approaching dangerous territory!


2.2.2 User defined types and classes

Let us say you have a C function which expects a pointer to an
abstract data type as input:

   void abstract_method( abstract_type * at );

And that you have implemented the Python class AT which wraps a
pointer to a at instance in a "c_ptr" attribute. If the AT class
contains a method:

  def from_param( self ):
      return self.c_ptr 

The AT class can then be used as a Python type in the restype and
argtypes attributes. To make it available in the prototyping as well
you must register the type:

   CWrapper.registerType( "at" , AT )


3 The C code

The C libraries are to a large extent developed with abstract types
like:

  typedef struct {
     .....
     .....
  } abs_type; 

and "methods" like:

  abs_type * abs_type_alloc( ) { }
  void       abs_type_free( abs_type * at ) {} 
  int        abs_type_get_an_int( const abs_type * at) {}  
  void       abs_type_set_an_int( abs_type * at , int value) {}

it has therefor been relatively easy to map this onto Python classes
and give a pythonic feel to the whole thing. As a ground rule each C
file implements one struct; this struct is wrapped in a Python module
with the same name and a Python class with CamelCaps naming:

    C                                  Python
    ecl_kw.c implements ecl_kw_type    ecl_kw.py implements EclKW



4 Common structure of the wrapping

The wrapping of the libraries (currently only libecl is anything close
to complete) follow roughly the same structure:

  1. Load the shared library

  2. For each C "class" you wish to wrap {

       2.1. Prototype the C functions you wish to use by creating Python
            function objects with correct restype and argtypes
            attributes for the functions you are interested in, using
            the CWrapper.prototype() function.

       2.2. Create the Python class - based on the prototype functions
            from 2.1 above.

     }     
     
The following excerpt from ecl_kw.y illustrates this:

    ------------------------------------------------------------
    # Load the shared library
    import libecl                                    <---  Step 1

    Class EclKW:                                     <-------------·
          # Pure Python code to implement the EclKW class,         |
          # based on the functions prototyped below.               |   Step 3
          ....                                       <-------------· 
    
    # Create a wrapper instance which wraps the libecl library. <--------·
    cwrapper = CWrapper( libecl.lib )                                    |
                                                                         | 
    # Register the type mapping "ecl_kw" <-> EclKW                       | Step 2
    cwrapper.registerType( "ecl_kw" , EclKW )                            |
                                                                         |
    # Prototype the functions needed to implement the Python class       |
    cfunc.alloc_new = cwrapper.prototype("long ecl_kw_alloc( char* , int , int )")
    cfunc.free      = cwrapper.prototype("void ecl_kw_free( ecl_kw )")   |                 
    ....                                                        <--------· 
    ------------------------------------------------------------

These three steps are described in more detail in 4.1 - 4.3 below.


4.1 Loading the shared library

For loading the shared library 'libecl.so' there is a module
'libecl.py' which calls the actual loading function, load() in
ert.cwrap.clib.py. Subsequently the library instance will be a 'lib'
attribute of the the libecl module, so that subsequent functions which
need access to the function objects pointing to C functions, like
e.g. the prototype function in the CWrapper class, will use this
attribute.


4.2 Prototyping

The bottom part of the Python modules typically look 


The prototyped functions should __NOT__ be used outside the file scope
where they are defined.



4.3 Python classes

All the main Python classes wrap a C based structure, and contain
roughly the same structure:

  * The __init__() function, or alternatively a classmethod
    constructor calls the C based constructor, like
    e.g. ecl_grid_alloc() and internalize the return value in the
    attribute 'c_ptr'; alternatively the c_ptr might come as a shared
    reference from another function.

  * The __del__ function is called when the Python object is garbage
    collected, then the corresponding C free function should be
    called, e.g. ecl_grid_free().
    

The c_ptr

5 Caveats

As a user of the library it should __NOT__ be necessary to be aware of
these possible pitfalls, but if you wish to extend the library it is
essential to understand these points.


5.1 Garbage collection and container types

5.2 Funny types


6 Installation in Statoil

In Statoil the ert Python libraries are installed in the /project/res
hierarchy.
