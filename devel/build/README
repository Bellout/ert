svn checkout
============
To check out the EnKF sources type the following command in a shell:

bash% svn co http://sdp.statoil.no/reservoir/EnKF/devel EnKF

The final EnKF is the name of a directory which will be created to
hold the newly checked out code; where in your personal filesystem you
put this is 100% arbitrary.

When the checkout is complete you should have a EnKF directory, if you
cd into this directory you should see the following subdirectories:

bin         	 - not actively maintained
doc         	 - not actively maintained
Helps       	 - not actively maintained
libecl(C)   	 - library to read/write ECLIPSE restart/summary/grid/... files
libenkf(C)  	 - Various EnKF objects - only partly in use - the future?
libhash(C)  	 - Small library implementing a hash table.
libutil(C)  	 - Small library with lots of utility functions - no state.
librms(C)   	 - Small library for reading and writing RMS roff files
libsched(C) 	 - Library to parse selected keywords from SCHEDULE file
libsample(F90)   - library to sample smooth gaussian fields
libanalysis(F90) - library to do the real EnKF core - i.e. calculate
                   the update matrix.
SOURCE(F90)      - The source code for the main EnKF executable(s).



32/64 bits
==========
The EnKF system is still stuck in 32 bit - in principle there should
be no reason not to switch to 64 bits - but you never know?! All the C
based libraries are compiled with a switch mflag=m32 to gcc, and this
is also embedded in the filenames, i.e. libecl_m32.a.  For the fortran
libraries/executable we use a 32 bit compiler.


External libraries
==================
You will need the external libraries fftw3, blas and lapack. blas and
lapack are hopefully already installed on your machine, the fftw3
library can be downloaded from http://www.fftw.org. In addition you
might need special libraries for your compiler, i.e. the ifortcore
library.

The external libraries can be placed whereever you want, but read
about the path_config file below.


Executables in path
===================
The following executables must be in your path:

  Scripts/f90dep.py         [available as f90dep]
  Scripts/select_model.py   [available as select_model]
  svnversion
  ifort                     [32 bit fortran 90 compiler]
  gcc                       [gnu C compiler]



The path_config file 
==================== 
Now - you should change to the directory build/. If you have checked
out the source code according to the checkout command listed at the
top, all the libraries will be located in a common hierarchy - however
we have attempted to make the build process slightly more general. In
principle the various libraries can be spread all over the place;
shared among users e.t.c. To facilitate this we use a file called
path_config which lists the location of all the libraries.

Create the path_config file - see the template path_config.template
for how to do it. When you have built the path_config file you can run
the script make_tags.py - this will index all source code into a tags
file, which can be used with e.g. emacs or vi, *and* add a link from
every src/ directory to the path_config file.

The two last variables in the path_config file are EXTERNAL_LIB_PATH,
end ENKF_BIN_PATH. They are slightly different from the other variabls
in the path_config file. The variable EXTERNAL_LIB_PATH should point
to a directory which contains (symlinks to) all external libraries
needed in the build (not including external libraries in standard
locations). So, when you have installed the libfftw3 library in
/some/funny/path/i32/lib you should add a symbolic link from the path
given in EXTERNAL_LIB_PATH to
/some/funny/path/i32/lib/libfftw3.(so|a).

The path ENKF_BIN_PATH is used to store the external binaries needed
by the EnKF application. Set the variable ENKF_BIN_PATH to some value,
and create the corresponding directory. Finally you should copy the
script Scripts/ecl_submit.py to the ENKF_BIN_PATH location. Observe
that the target script should be *without* extension:
 
   bash%: cp ../Scripts/ecl_submit.py $ENKF_BIN_PATH/ecl_submit


The location of the eclipse executable(s):
==========================================
The Eclipse simulations are submitted through a scripts
Scripts/ecl_submit.py; this script reads configuration information
(i.e. where to find the eclipse executables) from a file called
ecl_env.py. This file does not exist yet, you should copy the file
Scripts/ecl_env.py.template to Scripts/ecl_env.py and update it.
If there are several users of EnKF on the same system, they can (and
should??) share the submit command.


Building the libraries
======================
Start building the libraries. For each library this should only amount
to changing into to src/ directory and do make. The libraries should
be built in the following order:

   1: libhash(C)
   2: libutil(C)
   3: libecl(C)
   4: libsched(C)
   5: librms(C)
   6: libsample(F90)
   7: libanalysis(F90)
   8: libenkf(C)

If you wish you can also use the build_all.py script which will build
the libraries in the correct order.



Building the executable for an existing model
=============================================
When all libraries have built successfully you can build the
executable. Go to the SOURCE directory. The SOURCE directory is
organized and build process is organized as follows:

o All the model spesific files are located in a subdirectories
  Model_XXX, and the "active" model is based on symlinks into the
  relevant directory.

o All the source files have extension .F90 - prior to compiling
  they are piped through the cpp preprosessor to generate .f90
  files. These f90 files are stored temporarily in a model spesific
  tmp directory - this way the actual build is not done on an NFS
  mounted volume, a side effect which increases build speed
  dramatically.

The steps you must go through to build a model is the following:

1: You must make up your mind on which model to build.

2: Go manually into the Model_xxx directory of the chosen model. In
   this directory you should create a file called user_defs.inc
   which looks like this:
----------------------------
character(Len=80), Parameter :: code_path         = "/h/a152128/EnKF/devel/EnKF/SOURCE/Model_OmegaNorth/"
character(Len=80), Parameter :: code_include_path = "/h/a152128/EnKF/devel/EnKF/SOURCE/Model_OmegaNorth/include/"
character(len=80), parameter :: scriptdir         = "/h/a152128/EnKF/devel/EnKF/Scripts/"
character(len=80), parameter :: helpdir           = "/h/a152128/EnKF/devel/EnKF/Helps/"
----------------------------
   Of course you should replace the path-values on the right with
   the ones which are correct in your case.
 
3: Go back to the SOURCE directory and type:

   bash% select_model Model_xxx

   to actually select the model (i.e. add some symbolic links). In
   addition to establishing the model spesific links, this command
   will also evaluate dependencies++

4: Type make - and keep your fingers crossed.

If this worked out allright you have built an EnKF executable for
one of the existing models successfully - maybe not very
interesting, but you have at least verified that the toolchain
works. 

To build an EnKF executable for a new model is a quite significant
excercise in bootstrapping - stay tuned!


Building the executable for a new model
=======================================
Hard work ...




